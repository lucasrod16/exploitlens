package vuln

import (
	"database/sql"
	"strings"

	"github.com/anchore/grype/grype/match"
	"github.com/anchore/grype/grype/pkg"
	"github.com/defenseunicorns/zarf/src/pkg/message"
	"github.com/lucasrod16/exploitlens/pkg/vulndb"
)

func PrepareVulnerabilityMetadata(matchMap map[pkg.ID][]match.Match) (vulns, exploitedVulns VulnerabilityList, err error) {
	dbConnection, err := vulndb.ConnectToVulnDB()
	if err != nil {
		return nil, nil, err
	}
	defer dbConnection.Close()

	spinner := message.NewProgressSpinner("Preparing vulnerability metadata")
	defer spinner.Stop()

	vulns, err = getVulnerabilities(dbConnection, matchMap)
	if err != nil {
		return nil, nil, err
	}
	exploitedVulns, err = getKnownExploitedVulnerabilities(vulns)
	if err != nil {
		return nil, nil, err
	}
	spinner.Success()
	return vulns, exploitedVulns, nil
}

func getVulnerabilities(dbConnection *sql.DB, matchMap map[pkg.ID][]match.Match) (vulns VulnerabilityList, err error) {
	for _, matches := range matchMap {
		for _, match := range matches {
			severity, err := getCVSSseverity(dbConnection, match.Vulnerability.ID)
			if err != nil {
				return nil, err
			}
			vuln := Vulnerability{
				PkgName:          match.Package.Name,
				InstalledVersion: match.Package.Version,
				FixedVersion:     strings.Join(match.Vulnerability.Fix.Versions, ""),
				PkgType:          match.Package.Type.PackageURLType(),
				VulnID:           match.Vulnerability.ID,
				Severity:         severity,
			}
			vulns = append(vulns, vuln)
		}
	}
	return vulns, nil
}
